<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Algorithms Cheat Sheet</title>
    <style>
        @page { size: A4; margin: 0.5cm; }
        body { font-family: 'Courier New', monospace; font-size: 8px; line-height: 1.1; margin: 0; padding: 0.2cm; width: 100%; max-width: 21cm; }
        h2 { font-size: 10px; margin: 2px 0; border-bottom: 1px solid #000; }
        h3 { font-size: 9px; margin: 1px 0; }
        ul, ol { margin: 1px 0; padding-left: 10px; }
        li { margin: 0.5px 0; }
        code { font-size: 7px; background: #f0f0f0; }
        table { border-collapse: collapse; width: 100%; font-size: 7px; }
        th, td { border: 1px solid #000; padding: 1px 2px; text-align: left; }
        .col { float: left; width: 48%; margin-right: 2%; }
        .clear { clear: both; }
    </style>
</head>
<body>
    <div class="col">
        <h2>Binary Search</h2>
        <p><strong>Assumption:</strong> Sorted array <code>A[0..n-1]</code>. Find target x.</p>
        <ul>
            <li>low = 0, high = n-1</li>
            <li>while low ≤ high:</li>
            <li>&nbsp;&nbsp;mid = (low + high) // 2</li>
            <li>&nbsp;&nbsp;if A[mid] == x: return mid</li>
            <li>&nbsp;&nbsp;elif A[mid] < x: low = mid + 1</li>
            <li>&nbsp;&nbsp;else: high = mid - 1</li>
            <li>return -1 (not found)</li>
        </ul>
        <p><strong>Complexity:</strong> Time: $O(\log n)$, Space: $O(1)$</p>
        <p><strong>Notes:</strong> No duplicates assumed; variants for first/last occurrence.</p>

        <h2>Depth First Search (DFS)</h2>
        <p><strong>For:</strong> Graph traversal (undirected/directed). Visit all reachable nodes.</p>
        <ul>
            <li>Stack (or recursion): Start from source s.</li>
            <li>Visited set V; while stack not empty:</li>
            <li>&nbsp;&nbsp;pop u; if u not in V: add to V, process u, push unvisited neighbors</li>
            <li>Recursive: def dfs(u): mark visited[u]; for v in adj[u]: if not visited[v]: dfs(v)</li>
        </ul>
        <p><strong>Complexity:</strong> Time: $O(V+E)$, Space: $O(V)$ (recursion stack)</p>
        <p><strong>Uses:</strong> Paths, cycles, components, topological sort.</p>

        <h2>Breadth First Search (BFS)</h2>
        <p><strong>For:</strong> Graph traversal. Level-order (shortest path in unweighted).</p>
        <ul>
            <li>Queue Q; enqueue s, visited[s]=true</li>
            <li>while Q not empty:</li>
            <li>&nbsp;&nbsp;dequeue u; process u</li>
            <li>&nbsp;&nbsp;for v in adj[u]: if not visited[v]: visited[v]=true, enqueue v, parent[v]=u</li>
        </ul>
        <p><strong>Complexity:</strong> Time: $O(V+E)$, Space: $O(V)$</p>
        <p><strong>Uses:</strong> Shortest path (unweighted), levels, connected components.</p>
    </div>
    <div class="col">
        <h2>Dijkstra's Algorithm</h2>
        <p><strong>For:</strong> Shortest paths from s in graph with non-neg weights. Output dist[] to all nodes.</p>
        <ul>
            <li>Priority queue PQ (min-heap on dist); dist[s]=0, others=∞; insert (s,0)</li>
            <li>while PQ not empty:</li>
            <li>&nbsp;&nbsp;u = extract-min(PQ)</li>
            <li>&nbsp;&nbsp;if dist[u] updated, skip</li>
            <li>&nbsp;&nbsp;for each neighbor v of u (weight w):</li>
            <li>&nbsp;&nbsp;&nbsp;&nbsp;if dist[v] > dist[u] + w: dist[v] = dist[u] + w, update PQ</li>
        </ul>
        <p><strong>Complexity:</strong> Time: $O((V+E)\log V)$ (binary heap), Space: $O(V)$</p>
        <p><strong>Notes:</strong> No neg weights; use Fibonacci heap for $O(E + V\log V)$.</p>

        <h2>A* Search</h2>
        <p><strong>For:</strong> Heuristic shortest path (e.g., grid/maps). Like Dijkstra but guided.</p>
        <ul>
            <li>f(n) = g(n) + h(n); g=dist from start, h=heuristic to goal (admissible: h ≤ true cost)</li>
            <li>Priority queue on f; same as Dijkstra but priority = g + h</li>
            <li>Relax: if g(v) > g(u) + w: update g(v), f(v)</li>
        </ul>
        <p><strong>Complexity:</strong> Time: Depends on h; optimal if consistent ($h(u) \leq c(u,v) + h(v)$)</p>
        <p><strong>Notes:</strong> h=0 → Dijkstra; Manhattan/Euclidean for grids. Detects if no path.</p>
        <div class="clear"></div>

        <h2>Minimum Spanning Tree (MST)</h2>
        <p><strong>For:</strong> Undirected, connected graph with weights. Min total weight tree covering all vertices (no cycles).</p>
        <h3>Prim's Algorithm</h3>
        <ul>
            <li>Start from arbitrary s; key[v]=∞ (min edge to tree), inMST[v]=false; key[s]=0</li>
            <li>for _ in 1 to V:</li>
            <li>&nbsp;&nbsp;u = extract-min key among not inMST</li>
            <li>&nbsp;&nbsp;inMST[u]=true</li>
            <li>&nbsp;&nbsp;for v adj u: if not inMST[v] and w(u,v) < key[v]: key[v]=w(u,v), parent[v]=u</li>
        </ul>
        <p>Time: $O((V+E)\log V)$ (heap)</p>

        <h3>Kruskal's Algorithm</h3>
        <ul>
            <li>Sort all E edges by weight ascending</li>
            <li>Union-Find (DSU) for vertices; MST empty</li>
            <li>for each sorted edge (u,v,w):</li>
            <li>&nbsp;&nbsp;if find(u) != find(v): union(u,v); add to MST</li>
        </ul>
        <p>Time: $O(E \log E)$ (sort + union-find α(V))</p>
        <p><strong>Notes:</strong> Graph connected; for forests, add all components.</p>

        <h2>Bellman-Ford Algorithm</h2>
        <p><strong>For:</strong> Shortest paths from s; handles neg weights (no neg cycles).</p>
        <ul>
            <li>dist[s]=0, others=∞</li>
            <li>for i=1 to |V|-1:</li>
            <li>&nbsp;&nbsp;for each edge (u,v,w) in E:</li>
            <li>&nbsp;&nbsp;&nbsp;&nbsp;if dist[v] > dist[u] + w: dist[v] = dist[u] + w</li>
            <li><em>Check neg cycle:</em> for each edge: if dist[v] > dist[u] + w: cycle!</li>
        </ul>
        <p><strong>Complexity:</strong> Time: $O(VE)$, Space: $O(V)$</p>
        <p><strong>Notes:</strong> Detects neg cycles; slower than Dijkstra; use SPFA variant for avg faster.</p>
    </div>
    <div class="clear"></div>
</body>
</html>
